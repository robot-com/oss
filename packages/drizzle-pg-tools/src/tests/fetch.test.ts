import assert from 'node:assert/strict'
import { test } from 'node:test'
import { createLocalDatabase } from '../db'
import { fetchSchemaPgLite } from '../schema/fetch'

test('fetch empty schema', async () => {
    const client = (await createLocalDatabase({})).$client
    const schema = await fetchSchemaPgLite(client)

    assert.equal(schema.tables.length, 0)
    assert.equal(schema.enums.length, 0)
    assert.equal(schema.views.length, 0)
    assert.equal(schema.schema, 'public')
    assert.ok(schema.generated_at)
    assert.ok(Array.isArray(schema.tables))
    assert.ok(Array.isArray(schema.enums))
    assert.ok(Array.isArray(schema.views))
})

test('fetch table with various column types and properties', async () => {
    const client = (await createLocalDatabase({})).$client

    await client.query(`
        CREATE TABLE test (
            id INT NOT NULL,
            name TEXT DEFAULT 'anonymous',
            price NUMERIC(10, 2),
            code VARCHAR(10),
            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )
    `)

    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    assert.ok(table, 'Table should exist')

    assert.equal(table.columns.length, 5)

    const idCol = table.columns.find((c) => c.name === 'id')
    assert.ok(idCol)
    assert.equal(idCol.data_type, 'integer')
    assert.equal(idCol.is_nullable, false)
    assert.equal(idCol.default, null)

    const nameCol = table.columns.find((c) => c.name === 'name')
    assert.ok(nameCol)
    assert.equal(nameCol.data_type, 'text')
    assert.equal(nameCol.is_nullable, true)
    assert.equal(nameCol.default, "'anonymous'::text")

    const priceCol = table.columns.find((c) => c.name === 'price')
    assert.ok(priceCol)
    assert.equal(priceCol.data_type, 'numeric')
    assert.equal(priceCol.numeric_precision, 10)
    assert.equal(priceCol.numeric_scale, 2)

    const codeCol = table.columns.find((c) => c.name === 'code')
    assert.ok(codeCol)
    assert.equal(codeCol.data_type, 'character varying')
    assert.equal(codeCol.max_length, 10)

    const createdCol = table.columns.find((c) => c.name === 'created_at')
    assert.ok(createdCol)
    assert.equal(createdCol.data_type, 'timestamp with time zone')
    assert.equal(createdCol.default, 'now()')
})

test('fetch column with identity and generated properties', async () => {
    const client = (await createLocalDatabase({})).$client

    await client.query(`
        CREATE TABLE test (
            id_default INT GENERATED BY DEFAULT AS IDENTITY,
            id_always INT GENERATED ALWAYS AS IDENTITY,
            name TEXT,
            name_upper TEXT GENERATED ALWAYS AS (UPPER(name)) STORED
        )
    `)

    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    assert.ok(table)

    const idDefault = table.columns.find((c) => c.name === 'id_default')
    assert.ok(idDefault)
    assert.equal(idDefault.is_identity, true)
    assert.equal(idDefault.identity_generation, 'BY DEFAULT')
    assert.equal(idDefault.is_generated, false)

    const idAlways = table.columns.find((c) => c.name === 'id_always')
    assert.ok(idAlways)
    assert.equal(idAlways.is_identity, true)
    assert.equal(idAlways.identity_generation, 'ALWAYS')
    assert.equal(idAlways.is_generated, false)

    const nameUpper = table.columns.find((c) => c.name === 'name_upper')
    assert.ok(nameUpper)
    assert.equal(nameUpper.is_identity, false)
    assert.equal(nameUpper.is_generated, true)
    assert.equal(nameUpper.generation_expression, 'upper(name)')
})

test('fetch table with primary key and check constraints', async () => {
    const client = (await createLocalDatabase({})).$client

    await client.query(`
        CREATE TABLE products (
            id INT PRIMARY KEY,
            name TEXT NOT NULL,
            price INT,
            CONSTRAINT price_check CHECK (price > 0)
        )
    `)

    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    assert.ok(table)
    assert.equal(table.constraints.length, 2)

    const pk = table.constraints.find((c) => c.type === 'PRIMARY KEY')
    assert.ok(pk)
    assert.equal(pk.name, 'products_pkey')
    assert.equal(pk.definition, 'PRIMARY KEY (id)')

    const check = table.constraints.find((c) => c.type === 'CHECK')
    assert.ok(check)
    assert.equal(check.name, 'price_check')
    assert.equal(check.definition, 'CHECK ((price > 0))')

    // The PK should also create a unique index
    const pkIndex = table.indexes.find((i) => i.name === 'products_pkey')
    assert.ok(pkIndex)
    assert.equal(pkIndex.is_constraint_index, true)
    assert.equal(pkIndex.is_unique, true)
    assert.equal(pkIndex.is_valid, true)
})

test('fetch table with composite primary key', async () => {
    const client = (await createLocalDatabase({})).$client

    await client.query(`
        CREATE TABLE order_items (
            order_id INT,
            product_id INT,
            PRIMARY KEY (order_id, product_id)
        )
    `)

    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    assert.ok(table)

    const pk = table.constraints.find((c) => c.type === 'PRIMARY KEY')
    assert.ok(pk)
    assert.equal(pk.name, 'order_items_pkey')
    assert.equal(pk.definition, 'PRIMARY KEY (order_id, product_id)')

    const pkIndex = table.indexes.find((i) => i.name === 'order_items_pkey')
    assert.ok(pkIndex)
    assert.equal(pkIndex.columns.length, 2)
    assert.equal(pkIndex.columns[0].name, 'order_id')
    assert.equal(pkIndex.columns[1].name, 'product_id')
})

test('fetch table with foreign key constraints', async () => {
    const client = (await createLocalDatabase({})).$client

    await client.query('CREATE TABLE users (id INT PRIMARY KEY)')
    await client.query(`
        CREATE TABLE posts (
            id INT PRIMARY KEY,
            user_id INT,
            CONSTRAINT posts_user_id_fkey FOREIGN KEY (user_id)
                REFERENCES users(id)
                ON DELETE CASCADE
                ON UPDATE RESTRICT
        )
    `)

    const schema = await fetchSchemaPgLite(client)
    const postsTable = schema.tables.find((t) => t.name === 'posts')
    assert.ok(postsTable)
    assert.equal(postsTable.foreign_keys.length, 1)

    const fk = postsTable.foreign_keys[0]
    assert.equal(fk.name, 'posts_user_id_fkey')
    assert.deepEqual(fk.columns, ['user_id'])
    assert.equal(fk.foreign_table, 'users')
    assert.deepEqual(fk.foreign_columns, ['id'])
    assert.equal(fk.on_delete, 'CASCADE')
    assert.equal(fk.on_update, 'RESTRICT')
    assert.equal(fk.match_option, 'SIMPLE')
})

test('fetch advanced indexes (composite, order, partial)', async () => {
    const client = (await createLocalDatabase({})).$client

    await client.query(`
        CREATE TABLE test (
            id INT,
            name TEXT,
            category TEXT,
            deleted_at TIMESTAMP
        )
    `)
    await client.query(
        'CREATE UNIQUE INDEX idx_name_cat ON test (name ASC, category DESC)'
    )
    await client.query(
        'CREATE INDEX idx_active ON test (id) WHERE deleted_at IS NULL'
    )

    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    assert.ok(table)
    assert.equal(table.indexes.length, 2)

    const compositeIndex = table.indexes.find((i) => i.name === 'idx_name_cat')
    assert.ok(compositeIndex)
    assert.equal(compositeIndex.is_unique, true)
    assert.equal(compositeIndex.columns.length, 2)
    assert.equal(compositeIndex.columns[0].name, 'name')
    assert.equal(compositeIndex.columns[0].sort_order, 'ASC')
    assert.equal(compositeIndex.columns[0].nulls_order, 'NULLS LAST')
    assert.equal(compositeIndex.columns[1].name, 'category')
    assert.equal(compositeIndex.columns[1].sort_order, 'DESC')
    assert.equal(compositeIndex.columns[1].nulls_order, 'NULLS FIRST') // DESC default
    assert.equal(compositeIndex.predicate, null)

    const partialIndex = table.indexes.find((i) => i.name === 'idx_active')
    assert.ok(partialIndex)
    assert.equal(partialIndex.is_unique, false)
    assert.equal(partialIndex.columns.length, 1)
    assert.equal(partialIndex.predicate, 'deleted_at IS NULL')
})

test('fetch enums and views', async () => {
    const client = (await createLocalDatabase({})).$client

    await client.query("CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy')")
    await client.query('CREATE TABLE person (name TEXT, current_mood mood)')
    await client.query(
        "CREATE VIEW happy_people AS SELECT name FROM person WHERE current_mood = 'happy'"
    )

    const schema = await fetchSchemaPgLite(client)

    assert.equal(schema.enums.length, 1)
    const moodEnum = schema.enums[0]
    assert.equal(moodEnum.name, 'mood')
    assert.deepEqual(moodEnum.values, ['sad', 'ok', 'happy'])

    assert.equal(schema.views.length, 1)
    const happyView = schema.views[0]
    assert.equal(happyView.name, 'happy_people')
    assert.ok(happyView.definition.includes("current_mood = 'happy'::mood"))

    const personTable = schema.tables.find((t) => t.name === 'person')
    assert.ok(personTable)
    const moodColumn = personTable.columns.find(
        (c) => c.name === 'current_mood'
    )
    assert.ok(moodColumn)
    assert.equal(moodColumn.data_type, 'USER-DEFINED')
    assert.equal(moodColumn.udt_name, 'mood')
})

test('fetch triggers', async () => {
    const client = (await createLocalDatabase({})).$client

    await client.query(`
        CREATE TABLE users (
            id INT PRIMARY KEY,
            name TEXT,
            updated_at TIMESTAMP
        )
    `)
    await client.query(`
        CREATE OR REPLACE FUNCTION update_updated_at_column()
        RETURNS TRIGGER AS $$
        BEGIN
           NEW.updated_at = now();
           RETURN NEW;
        END;
        $$ language 'plpgsql';
    `)
    await client.query(`
        CREATE TRIGGER set_updated_at
        BEFORE UPDATE ON users
        FOR EACH ROW
        EXECUTE FUNCTION update_updated_at_column();
    `)

    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    assert.ok(table)
    assert.equal(table.triggers.length, 1)

    const trigger = table.triggers[0]
    assert.equal(trigger.name, 'set_updated_at')
    assert.equal(trigger.timing, 'BEFORE')
    assert.equal(trigger.event, 'UPDATE')
    assert.equal(trigger.level, 'ROW')
    assert.equal(trigger.function_name, 'update_updated_at_column')
    assert.equal(trigger.function_schema, 'public')
})

test('fetch comments/descriptions for all object types', async () => {
    const client = (await createLocalDatabase({})).$client

    await client.query("CREATE TYPE status AS ENUM ('active', 'inactive')")
    await client.query("COMMENT ON TYPE status IS 'The status of an entity.'")

    await client.query(
        'CREATE TABLE test (id INT PRIMARY KEY, name TEXT, parent_id INT)'
    )
    await client.query("COMMENT ON TABLE test IS 'This is a test table.'")
    await client.query(
        "COMMENT ON COLUMN test.name IS 'The name of the entity.'"
    )

    await client.query(
        "ALTER TABLE test ADD CONSTRAINT name_not_empty CHECK (name <> '')"
    )
    await client.query(
        "COMMENT ON CONSTRAINT name_not_empty ON test IS 'Name cannot be empty.'"
    )

    await client.query(
        'ALTER TABLE test ADD CONSTRAINT fk_parent FOREIGN KEY (parent_id) REFERENCES test(id)'
    )
    await client.query(
        "COMMENT ON CONSTRAINT fk_parent ON test IS 'Self-referencing parent.' "
    )

    await client.query('CREATE INDEX idx_test_name ON test (name)')
    await client.query(
        "COMMENT ON INDEX idx_test_name IS 'Index for fast name lookup.'"
    )

    await client.query('CREATE VIEW test_view AS SELECT id FROM test')
    await client.query(
        "COMMENT ON VIEW test_view IS 'A view of the test table.'"
    )

    const schema = await fetchSchemaPgLite(client)

    assert.equal(schema.enums[0].description, 'The status of an entity.')
    assert.equal(schema.views[0].description, 'A view of the test table.')

    const table = schema.tables[0]
    assert.ok(table)
    assert.equal(table.description, 'This is a test table.')
    assert.equal(
        table.columns.find((c) => c.name === 'name')?.description,
        'The name of the entity.'
    )
    assert.equal(
        table.constraints.find((c) => c.name === 'name_not_empty')?.description,
        'Name cannot be empty.'
    )
    assert.equal(
        table.indexes.find((i) => i.name === 'idx_test_name')?.description,
        'Index for fast name lookup.'
    )
    assert.equal(
        table.foreign_keys.find((fk) => fk.name === 'fk_parent')?.description,
        'Self-referencing parent.'
    )
})

test('kitchen sink: fetch schema with multiple interconnected features', async () => {
    const client = (await createLocalDatabase({})).$client

    // 1. Enum
    await client.query("CREATE TYPE user_role AS ENUM ('admin', 'member')")

    // 2. Users Table
    await client.query(`
        CREATE TABLE users (
            id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            email TEXT NOT NULL UNIQUE,
            role user_role NOT NULL DEFAULT 'member',
            created_at TIMESTAMPTZ DEFAULT NOW(),
            updated_at TIMESTAMPTZ
        )
    `)
    await client.query("COMMENT ON TABLE users IS 'Stores user accounts.'")

    // 3. Posts Table
    await client.query(`
        CREATE TABLE posts (
            id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            author_id INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
            title TEXT NOT NULL CHECK (length(title) > 3),
            published_at TIMESTAMPTZ
        )
    `)
    await client.query(
        'CREATE INDEX idx_posts_author ON posts (author_id, published_at DESC)'
    )

    // 4. Trigger
    await client.query(`
        CREATE OR REPLACE FUNCTION set_updated_at_func()
        RETURNS TRIGGER AS $$
        BEGIN
           NEW.updated_at = NOW();
           RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
    `)
    await client.query(`
        CREATE TRIGGER users_set_updated_at
        BEFORE UPDATE ON users
        FOR EACH ROW
        EXECUTE FUNCTION set_updated_at_func();
    `)

    // 5. View
    await client.query(`
        CREATE VIEW admin_users AS
        SELECT id, email FROM users WHERE role = 'admin'
    `)

    const schema = await fetchSchemaPgLite(client)

    // Assert Enums
    assert.equal(schema.enums.length, 1)
    assert.equal(schema.enums[0].name, 'user_role')

    // Assert Views
    assert.equal(schema.views.length, 1)
    assert.equal(schema.views[0].name, 'admin_users')

    // Assert Users Table
    const users = schema.tables.find((t) => t.name === 'users')
    assert.ok(users)
    assert.equal(users.description, 'Stores user accounts.')
    assert.equal(users.columns.length, 5)
    assert.equal(users.constraints.length, 2) // pkey, unique
    assert.equal(users.indexes.length, 2) // pkey, unique
    assert.equal(users.triggers.length, 1)
    assert.equal(users.triggers[0].name, 'users_set_updated_at')
    const roleCol = users.columns.find((c) => c.name === 'role')
    assert.ok(roleCol)
    assert.equal(roleCol.data_type, 'USER-DEFINED')
    assert.equal(roleCol.udt_name, 'user_role')

    // Assert Posts Table
    const posts = schema.tables.find((t) => t.name === 'posts')
    assert.ok(posts)
    assert.equal(posts.foreign_keys.length, 1)
    assert.equal(posts.foreign_keys[0].foreign_table, 'users')
    assert.equal(posts.foreign_keys[0].on_delete, 'CASCADE')
    assert.equal(posts.constraints.length, 2) // pkey, check
    assert.equal(posts.indexes.length, 2) // pkey, composite index
    const authorIndex = posts.indexes.find((i) => i.name === 'idx_posts_author')
    assert.ok(authorIndex)
    assert.equal(authorIndex.columns.length, 2)
    assert.equal(authorIndex.columns[1].sort_order, 'DESC')
})

test('fetch table with array column type', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE TABLE test (id INT, tags TEXT[])')
    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    const tagsCol = table.columns.find((c) => c.name === 'tags')
    assert.ok(tagsCol)
    assert.equal(tagsCol.data_type, 'ARRAY')
    assert.equal(tagsCol.udt_name, '_text')
})

test('fetch table with JSON and JSONB column types', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE TABLE test (metadata JSON, config JSONB)')
    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    const metaCol = table.columns.find((c) => c.name === 'metadata')
    const configCol = table.columns.find((c) => c.name === 'config')
    assert.ok(metaCol)
    assert.ok(configCol)
    assert.equal(metaCol.data_type, 'json')
    assert.equal(configCol.data_type, 'jsonb')
})

test('fetch table with various other data types (UUID, BYTEA, INET)', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE TABLE test (id UUID, data BYTEA, last_ip INET)')
    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    assert.equal(table.columns.find((c) => c.name === 'id')?.data_type, 'uuid')
    assert.equal(
        table.columns.find((c) => c.name === 'data')?.data_type,
        'bytea'
    )
    assert.equal(
        table.columns.find((c) => c.name === 'last_ip')?.data_type,
        'inet'
    )
})

test('fetch table with a simple UNIQUE constraint', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE TABLE users (id INT, email TEXT UNIQUE)')
    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    assert.equal(table.constraints.length, 1)
    const uniqueConstraint = table.constraints[0]
    assert.equal(uniqueConstraint.type, 'UNIQUE')
    assert.equal(uniqueConstraint.definition, 'UNIQUE (email)')
    assert.equal(table.indexes.length, 1)
    assert.equal(table.indexes[0].is_constraint_index, true)
})

test('fetch table with a composite UNIQUE constraint', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE TABLE test (a INT, b INT, UNIQUE (a, b))')
    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    const uniqueConstraint = table.constraints[0]
    assert.equal(uniqueConstraint.type, 'UNIQUE')
    assert.equal(uniqueConstraint.definition, 'UNIQUE (a, b)')
    const uniqueIndex = table.indexes[0]
    assert.equal(uniqueIndex.columns.length, 2)
    assert.equal(uniqueIndex.columns[0].name, 'a')
    assert.equal(uniqueIndex.columns[1].name, 'b')
})

test('fetch table with a UNIQUE constraint with NULLS NOT DISTINCT', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query(
        'CREATE TABLE test (name TEXT UNIQUE NULLS NOT DISTINCT)'
    )
    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    const uniqueConstraint = table.constraints[0]
    assert.equal(uniqueConstraint.type, 'UNIQUE')
    assert.equal(uniqueConstraint.nulls_not_distinct, true)
    const uniqueIndex = table.indexes[0]
    assert.equal(uniqueIndex.nulls_not_distinct, true)
})

test('fetch index with custom nulls ordering (NULLS FIRST)', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE TABLE test (name TEXT)')
    await client.query('CREATE INDEX idx_name ON test (name NULLS FIRST)')
    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    const index = table.indexes[0]
    assert.equal(index.columns[0].nulls_order, 'NULLS FIRST')
})

test('fetch index on an expression', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE TABLE users (email TEXT)')
    await client.query('CREATE INDEX idx_lower_email ON users (lower(email))')
    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    const index = table.indexes[0]
    assert.equal(
        index.definition,
        'CREATE INDEX idx_lower_email ON public.users USING btree (lower(email))'
    )
    assert.equal(index.columns.length, 0) // pg_attribute doesn't link expressions
})

test('fetch GIN index', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE TABLE test (data JSONB)')
    await client.query('CREATE INDEX idx_data_gin ON test USING GIN (data)')
    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    const index = table.indexes[0]
    assert.equal(index.name, 'idx_data_gin')
    assert.equal(index.index_type, 'gin')
})

test('fetch composite foreign key', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query(`
        CREATE TABLE parents (
            id1 INT,
            id2 INT,
            PRIMARY KEY (id1, id2)
        )
    `)
    await client.query(`
        CREATE TABLE children (
            child_id INT PRIMARY KEY,
            parent_id1 INT,
            parent_id2 INT,
            FOREIGN KEY (parent_id1, parent_id2) REFERENCES parents(id1, id2)
        )
    `)
    const schema = await fetchSchemaPgLite(client)
    const childrenTable = schema.tables.find((t) => t.name === 'children')
    assert.ok(childrenTable)
    const fk = childrenTable.foreign_keys[0]
    assert.deepEqual(fk.columns, ['parent_id1', 'parent_id2'])
    assert.deepEqual(fk.foreign_columns, ['id1', 'id2'])
})

test('fetch foreign key with ON DELETE SET NULL and ON UPDATE SET DEFAULT', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query(
        "CREATE TABLE users (id INT PRIMARY KEY, name TEXT DEFAULT 'guest')"
    )
    await client.query(`
        CREATE TABLE posts (
            id INT PRIMARY KEY,
            user_id INT REFERENCES users(id) ON DELETE SET NULL ON UPDATE SET DEFAULT
        )
    `)
    const schema = await fetchSchemaPgLite(client)
    const postsTable = schema.tables.find((t) => t.name === 'posts')
    assert.ok(postsTable)
    const fk = postsTable.foreign_keys[0]
    assert.equal(fk.on_delete, 'SET NULL')
    assert.equal(fk.on_update, 'SET DEFAULT')
})

test('fetch trigger for multiple events (INSERT OR UPDATE)', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE TABLE test (id INT, updated_at TIMESTAMPTZ)')
    await client.query(`
        CREATE OR REPLACE FUNCTION set_updated_at_func() RETURNS TRIGGER AS $$
        BEGIN NEW.updated_at = NOW(); RETURN NEW; END;
        $$ LANGUAGE plpgsql;
    `)
    await client.query(`
        CREATE TRIGGER test_trigger
        BEFORE INSERT OR UPDATE ON test
        FOR EACH ROW EXECUTE FUNCTION set_updated_at_func();
    `)
    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    const trigger = table.triggers[0]
    assert.equal(trigger.event, 'INSERT OR UPDATE')
})

test('fetch statement-level trigger', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE TABLE test (id INT)')
    await client.query(`
        CREATE OR REPLACE FUNCTION statement_func() RETURNS TRIGGER AS $$
        BEGIN RAISE NOTICE 'Statement executed'; RETURN NULL; END;
        $$ LANGUAGE plpgsql;
    `)
    await client.query(`
        CREATE TRIGGER test_trigger
        AFTER TRUNCATE ON test
        FOR EACH STATEMENT EXECUTE FUNCTION statement_func();
    `)
    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    const trigger = table.triggers[0]
    assert.equal(trigger.level, 'STATEMENT')
    assert.equal(trigger.event, 'TRUNCATE')
})

test('fetch INSTEAD OF trigger on a view', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE TABLE test (id INT)')
    await client.query('CREATE VIEW test_view AS SELECT * FROM test')
    await client.query(`
        CREATE OR REPLACE FUNCTION instead_of_func() RETURNS TRIGGER AS $$
        BEGIN RETURN NEW; END;
        $$ LANGUAGE plpgsql;
    `)
    await client.query(`
        CREATE TRIGGER test_view_trigger
        INSTEAD OF INSERT ON test_view
        FOR EACH ROW EXECUTE FUNCTION instead_of_func();
    `)
    // NOTE: The current query only fetches triggers on tables (relkind = 'r').
    // This test confirms that triggers on views are correctly ignored.
    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables.find((t) => t.name === 'test')
    assert.ok(table)
    assert.equal(table.triggers.length, 0)
})

test('ensure objects from other schemas are ignored', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE SCHEMA private')
    await client.query('CREATE TABLE private.secret (id INT)')
    await client.query("CREATE TYPE private.secret_enum AS ENUM ('a', 'b')")
    await client.query('CREATE VIEW private.secret_view AS SELECT 1')
    await client.query('CREATE TABLE public.data (id INT)')

    const schema = await fetchSchemaPgLite(client)
    assert.equal(schema.tables.length, 1)
    assert.equal(schema.tables[0].name, 'data')
    assert.equal(schema.enums.length, 0)
    assert.equal(schema.views.length, 0)
})

test('verify alphabetical ordering of tables in the final output', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE TABLE z_table (id INT)')
    await client.query('CREATE TABLE a_table (id INT)')
    await client.query('CREATE TABLE m_table (id INT)')

    const schema = await fetchSchemaPgLite(client)
    assert.equal(schema.tables.length, 3)
    assert.equal(schema.tables[0].name, 'a_table')
    assert.equal(schema.tables[1].name, 'm_table')
    assert.equal(schema.tables[2].name, 'z_table')
})

test('fetch table with no constraints or indexes', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE TABLE simple (id INT, name TEXT)')
    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    assert.ok(table)
    assert.equal(table.constraints.length, 0)
    assert.equal(table.indexes.length, 0)
    assert.equal(table.foreign_keys.length, 0)
    assert.equal(table.triggers.length, 0)
})

test('fetch schema with no views or enums but with tables', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE TABLE test (id INT)')
    const schema = await fetchSchemaPgLite(client)
    assert.equal(schema.tables.length, 1)
    assert.equal(schema.enums.length, 0)
    assert.equal(schema.views.length, 0)
})

test('fetch foreign key with NO ACTION referential action', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query('CREATE TABLE users (id INT PRIMARY KEY)')
    await client.query(`
        CREATE TABLE posts (
            id INT PRIMARY KEY,
            user_id INT REFERENCES users(id) ON DELETE NO ACTION ON UPDATE NO ACTION
        )
    `)
    const schema = await fetchSchemaPgLite(client)
    const postsTable = schema.tables.find((t) => t.name === 'posts')
    assert.ok(postsTable)
    const fk = postsTable.foreign_keys[0]
    assert.equal(fk.on_delete, 'NO ACTION')
    assert.equal(fk.on_update, 'NO ACTION')
})

test('fetch table with multiple check constraints', async () => {
    const client = (await createLocalDatabase({})).$client
    await client.query(`
        CREATE TABLE products (
            price INT CHECK (price > 0),
            discount INT,
            CONSTRAINT discount_check CHECK (discount < price)
        )
    `)
    const schema = await fetchSchemaPgLite(client)
    const table = schema.tables[0]
    assert.equal(table.constraints.length, 2)
    const priceCheck = table.constraints.find((c) =>
        c.definition.includes('price')
    )
    const discountCheck = table.constraints.find((c) =>
        c.definition.includes('discount')
    )
    assert.ok(priceCheck)
    assert.ok(discountCheck)
    assert.equal(priceCheck.type, 'CHECK')
    assert.equal(discountCheck.type, 'CHECK')
})
