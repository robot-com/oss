I'm creating a typescript backend framework. Please help to:

- fill in the gaps
- write long detailed documentation

Considerations:

- use markdown
- use the best possible documentation style

---

Name "Reliable Backend Framework" or "RBF"

Organization: robot.com

It has:

- queues (message/work queues for internal implementation)

- queries

- mutations

The mutations are used to modify data on the server. They typically involve creating, updating, or deleting records in the database.
Each mutation runs in the context of a database transaction, ensuring that all changes are atomic and consistent.
As a side effect of the mutation you can also enqueue other transactions to be executed after the mutation is complete.
You can also schedule mutations for later.

Queries run in a atomic transaction but readonly.


The api for for de developer must be simple.

```ts
type Schema = /* Drizzle schema */
type Context = /* Optional context for all operations */

const app = defineBackend<Context, Schema>({
    queues: {
        jobs: {
            middleware: (ctx: Context, db: PgTransaction, msg: Message) => {
                // Auth or something
                return {...ctx, user: { id: '1', name: 'John Doe' }}
            }
        }
        events: {}
    }
})



/// main.ts

async function main() {
    const backend = await createBackend(app, {
        context: {}
        db,
        queues: {
            jobs: natsQueue(...)
            events: natsQueue(...)
        }
    })

    await backend.start()

    /// ... long time after ...

    await backend.stop()
}

main()
```

To define a mutation:

```ts
const myProcedure = app.mutation(queueName, {
    path: 'jobs.create.$id', // The path to the mutation (params can be inferred from that pattern)
    input: z.object(/* ZodType */), // Optional, defaults to null
    output: z.object(/* ZodType */), // Optional
    handler: async ({ ctx, db, scheduler, input, params }) => { 
        // ctx: Original app context
        // db: Database transaction, drizzle PgTransaction
        // scheduler: Scheduler for enqueuing follow-up tasks (functions like enqueue, runAfter, runAt, publish)
        // input: Validated input
        // params: Inferred parameters from the path

        // Implementation of the mutation
    }
})
```

When a mutation is defined, it will get registered in the app. Also, it will return a Mutation object that is a 
reference to the mutation.
This reference can be used to enqueue the mutation (even if not strictly necessary for the app to work).
This mutation reference must include the path and the queue name

## Scheduler

```ts
const updateUser = app.mutation(...)

// ...
    scheduler.enqueue(updateUser, {
        params: {
            userId: '1',
        }
        input: {
            id: '1',
            name: 'John Doe'
        }
    })
// ...
```

## Atomicity

When inside a mutation another is enqueued, it will run after the current mutation is complete.
If the current mutation fails, the following mutation will not be executed.
If the current mutation is successful, the following mutation will be executed.
This must be impossible to fail.

To achieve this, the framework will use:
- postgres serializable transactions
- nats streams as workqueues
- dead letter queues (if a crash occurs in a bad time)
- unique execution ids and unique messages ids to detect duplicates
- mutations will be retried if they fail (using nats workqueue retry policy)
- before committing the transaction, the framework will enqueue the scheduled mutations in the db
- after the transaction is committed, the messages will be published to the nats streams and deleted from the db
  (if the system fails before the publish or before the deletion, the messages will be retried from the dead letter queue. Maybe using a cron job or something)

## Queries

Queries are defined similar to mutations, but:
- they are readonly
- they can't enqueue other mutations/queries

Queries do have a input too (equivalent to the input of a mutation)

Queries may be cached (controlled by something passed as options, similar of how scheduler is passed as options, but something to control the cache).

## Messages

Messages on nats must have a unique id. 
The unique id must be passed as a header.
The content of the message must be the input of the mutation/query.

There must also be a header indicating the reply to address.
The reply to address will be used when expecting a response from the query or mutation.

The unique id may be generated by the framework or by the developer.
Any other part of system that can publish to nats may use the api (without passing by the framework).

## Requesting the backend

The backend object can call queries or mutation and can also use the scheduler.
It will enqueue the mutations/queries and wait the response (all using nats).
It will also choose automatically a unique id (request id) for the request.

Other clients (that can use nats) may interact with the backend (as mentioned above).

## Middleware

Queues can have middleware. It will receive the original context, the database transaction and the message.
It can return a new context.

The middleware will be called before the handler of the mutation/query but in the same context/transaction.

## Mutations result

When a mutation is finished, it will save the result in the database (in the same transaction).
The result is linked to the requestId, queue name, and a hash of the input.

This will be used to deduplicate execution of the same mutation/query.

If requesting the same mutation, the result will be returned immediately (from the database).